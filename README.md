# Лабораторні роботи з дисципліни "Алгоритмів і структур даних"

## Виконав: Павлюк Олег Ігорович (Група ІР-23)

### Лабораторна робота №1 (Варіант 3 Рівень 1)

Дано відсортований масив цілих чисел `nums` за зростанням (від менших до більших значень). Напишіть функцію, яка повертає новий масив, в якому кожен елемент є квадратом відповідного елемента з масиву `nums`. Отриманий масив також повинен бути відсортованим за зростанням.
​
Поверніть новий масив відповідно до вхідних даних.
​
Вхідні дані: nums = [-4,-2,0,1,3]
Результат: [0,1,4,9,16]
​
Вхідні дані: nums = [1,2,3,4,5]
Результат: [1,4,9,16,25]
​
Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` та перевірити роботу вашої функції на прикладах, наведених вище

***
### Лабораторна робота №2 (Варіант 3 Рівень 1)

Ви граєте в альтернативний варiант покеру, де кожен гравець має в руках N карт, i
метою гри є набрати якомога довшу групу послiдовних карт.
Колода складається з карт, якi мають числову величину. Також, в колодi присутнi
джокери. Якщо в руцi гравця є джокери, вiн може присвоїти кожному будь-яку
величину на власний розсуд.
Вам роздали карти. Визначте довжину найдовшої послiдовностi карт, яку ви можете
скласти.
​
Вхiднi данi
масив цiлих чисел вiд 0 до 1000000 включно — величини окремих карт в
руцi. Загальна кiлькiсть карт в руцi не перевищує 10000.
Джокери позначаються величиною 0.
​
Перехiд через верхню межу» не дозволяється — `[999999, 1000000, 1, 2]` не вважається
коректною послiдовнiстю.
​
Ваша функція має повертати довжину найдовшої послiдовної групи, яку можна скласти з виданих карт.
​
Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` та перевірити роботу вашої функції на прикладах, наведених вище
​
Приклад 1
cards = 0 10 15 50 0 14 9 12 40
​
Результат
7
Пояснення: Можна замiнити один джокер на 11, iнший — на 13, i скласти таку
послiдовнiсть: 9, 10, 11, 12, 13, 14, 15.
​
Приклад 2
cards =1 1 1 2 1 1 3
Результат
3
​
Приклад 3
cards = 5 6 5 6 5 6 5 6 5 6 5 0 0
Результат
4
​
Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` та перевірити роботу вашої функції на прикладах, наведених вище

***
### Лабораторна робота №3 (Варіант 3 Рівень 1)

Для всіх задач слід написати тести з використанням бібліотеки unittest. Ваш проект має бути розділено на окремі папки для коду додатку та тестів (src та test відповідно).

При написанні коду дотримуйтесь стандарту PEP 8, який визначає правила форматування Python-коду, такі як відступи, довжина рядків, іменування змінних тощо. Для полегшення читабельності коду слід відформатувати ваш код з допомогою Black

Існує три найпоширеніші способи проходження бінарних дерев вглиб: прямий (pre-order), зворотній (post-order) та серединний (in-order).

Реалізуйте функцію, яка отримує на вхід вершину бінарного дерева та виконує його серединний обхід (in-order traversal) та повертає значення вузлів у списку у відповідному порядку.

Розглянемо таке бінарне дерево:

    1
   / \
  2    3
   \  / \
   5  6  7
Під час серединного обходу це дерево буде відвідане в такому порядку: [2, 5, 1, 6, 7, 3]

Функція in_order_traversal(root: BinaryTree) -> List отримує на вхід корінь бінарного дерева, який має наступний вигляд:

class BinaryTree:
    def __init__(self, value, left=None, right=None, parent=None):
        self.value = value
        self.left = left
        self.right = right
Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу BinaryTree наступним чином:

root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)

***
### Лабораторна робота №4 (Варіант 4 Рівень 3)

Нехай у вас задане прямокутне поле, на якому встановлені датчики в певних місцях. Перетніть його найкоротшим безпечним шляхом, не активуючи датчики.

Прямокутне поле має форму матриці M × N, і нам потрібно знайти найкоротший шлях від будь-якої клітинки в першому стовпці до будь-якої клітинки в останньому стовпці матриці. Датчики позначаються в матриці значенням 0, і всі її вісім суміжних осередків також можуть активувати датчики. Шлях можна побудувати лише з комірок зі значенням 1, і в будь-який момент ми можемо рухатися лише на один крок в одному з чотирьох напрямків. Допустимі ходи:

Вгору: (x, y) -> (x – 1, y)
Ліворуч: (x, y) -> (x, y – 1)
Перейти вниз: (x, y) -> (x + 1, y)
Праворуч: (x, y) -> (x, y + 1)
Наприклад, розглянемо таку матрицю:



Найкоротший безпечний шлях має довжину 11. Безпечний маршрут позначений зеленим кольором:



Для представлення графу слід використати матрицю, який зчитується з файлу input.txt
Алгоритм має вивести довжину найкоротшого шляху, або -1 якщо такого не існує
Результат слід вивести у файл output.txt


***
### Лабораторна робота №5 (Варіант 3 Рівень 3)

Для всіх задач слід написати тести з використанням бібліотеки unittest. Ваш проект має бути розділено на окремі папки для коду додатку та тестів (src та test відповідно).

При написанні коду дотримуйтесь стандарту PEP 8, який визначає правила форматування Python-коду, такі як відступи, довжина рядків, іменування змінних тощо. Для полегшення читабельності коду слід відформатувати ваш код з допомогою Black

Критично важливим є постачання газу між сховищами та містами пінгвінів взимку. Вибух газопроводів може призвести до дефіциту палива та викликати значні проблеми у домівках бравих пінгвінів. Тому ряд газопроводів зараз відключили для ремонту.

Ви, як студент курсу Алгоритми і структури даних маєте бажання допомогти Пінгвінам. Ви готові написати для них алгоритм, який перевірить, чи існує спосіб транспортування палива з будь-якого сховища до будь якого міста з використанням газопроводів, які не вивели в ремонт. Зауважте, що газ по трубі можна транспортувати лише в одному напрямку.

Для розв'язання цієї задачі пінгвіни надали вам:

список міст

список газосховищ

список активних газопроводів, у форматі [ ['Львів', 'Стрий'], ['Долина', 'Львів'], ['Сховище_1', 'Сховище_2'] ], де ['Львів', 'Стрий'] означає наявність газопроводу між містами Львів та Стрий, де подача газу відбувається від Львова до Стрия

Ваша програма має повернути результат у форматі: [ 'газосховище', ['місто_1', 'місто_2'] , де:

газосховище - назва газосховища
['місто_1', 'місто_2'] - список міст, до яких неможливо подати газ з цього газосховища
Зауважте, що газ може подаватись з газосховища до будь якого міста транзитом через інші міста.

У випадку, якщо є зв'язок між усіма газосховищами та містами, поверніть пустий список


***
